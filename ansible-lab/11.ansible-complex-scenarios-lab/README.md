
# Лабораторная работа №11

## Тема: Сложные сценарии в Ansible

### Цель работы
Изучить дополнительные возможности Ansible для создания сложных сценариев, включая обработку ошибок, использование фильтров, подстановок, циклов и шифрование конфиденциальных данных с помощью Vault.

### Задачи
#### 1. Решение проблем с неидемпотентными командами
- Использовать выражения `changed_when` и `failed_when` для обработки неидемпотентных задач.
- Создать задачу, которая инициализирует базу данных с помощью команды `django_manage` и делает ее идемпотентной.

#### 2. Использование фильтров
- Применить встроенные фильтры Jinja2 и дополнительные фильтры Ansible.
- Создать собственный фильтр для заключения строк в кавычки.

#### 3. Работа с подстановками
- Использовать функции подстановки для чтения данных из внешних источников.
- Применить подстановки `file`, `env`, `password`, `template` в сценариях Ansible.

#### 4. Создание сложных циклов
- Использовать различные механизмы итераций (`loop`, `with_items`, `with_dict`).
- Создать задачи, выполняющие обход сложных структур данных.

#### 5. Обработка ошибок с помощью блоков
- Использовать выражения `block`, `rescue`, `always` для обработки исключений и ошибок.
- Создать сценарий, который выполняет обновление приложения с возможностью отката в случае ошибки.

#### 6. Шифрование конфиденциальных данных с помощью Vault
- Использовать `ansible-vault` для шифрования файлов с конфиденциальными данными.
- Настроить сценарии Ansible для работы с зашифрованными файлами.

### Оборудование и ПО
- Компьютер с установленной ОС Linux.
- Установленный Ansible версии 2.9 или выше.
- Установленный Python 3.6 или выше.
- Текстовый редактор (например, Vim, Nano, VSCode).

### Ход работы
#### 1. Решение проблем с неидемпотентными командами
Создайте сценарий Ansible, который инициализирует базу данных с помощью django_manage:

```yaml
- name: Initialize the database
  django_manage:
    command: createdb --noinput --nodata
    app_path: "{{ proj_path }}"
    virtualenv: "{{ venv_path }}"
  register: result
  changed_when: '"Creating tables" in result.out|default("")'
```

Добавьте выражение `changed_when` для определения, изменилось ли состояние после выполнения задачи.

#### 2. Использование фильтров
Используйте встроенные фильтры для обработки данных в шаблонах Jinja2.

Создайте собственный фильтр `surround_by_quotes`:

Создайте файл `filter_plugins/surround_by_quotes.py` со следующим содержимым:

```python
class FilterModule():
    def filters(self):
        return {
            'surround_by_quotes': self.surround_by_quotes
        }

    def surround_by_quotes(self, a_list):
        return ['"%s"' % an_element for an_element in a_list]
```

Примените фильтр в шаблоне:

```jinja
ALLOWED_HOSTS = [{{ domains | surround_by_quotes | join(", ") }}]
```

#### 3. Работа с подстановками
Используйте функцию подстановки `file` для чтения содержимого файла:

```yaml
- name: Add my public key for SSH
  authorized_key:
    user: "{{ ansible_user }}"
    key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
```

Используйте подстановку `env` для получения значения переменной окружения:

```yaml
- name: Get the current shell
  debug:
    msg: "Current shell is {{ lookup('env', 'SHELL') }}"
```

Используйте подстановку `password` для генерации случайного пароля:

```yaml
- name: Create user with random password
  user:
    name: deploy
    password: "{{ lookup('password', 'passwords/deploy.txt', length=20) }}"
```

#### 4. Создание сложных циклов
Используйте цикл `with_dict` для обхода словаря:

```yaml
- name: Display interface information
  debug:
    msg: "Interface {{ item.key }} has IP {{ item.value.ipv4.address }}"
  with_dict: "{{ ansible_facts.interfaces }}"
```

Используйте цикл `loop` с комплексными объектами:

```yaml
- name: Create users
  user:
    name: "{{ item.name }}"
    groups: "{{ item.groups }}"
  loop:
    - { name: 'alice', groups: 'admins' }
    - { name: 'bob', groups: 'users' }
```

#### 5. Обработка ошибок с помощью блоков
Создайте сценарий с обработкой ошибок:

```yaml
- block:
    - name: Upgrade the application
      command: /usr/local/bin/upgrade_app
    - name: Run smoke tests
      command: /usr/local/bin/smoke_tests
  rescue:
    - name: Rollback the application
      command: /usr/local/bin/rollback_app
  always:
    - name: Notify team about deployment status
      mail:
        to: "team@example.com"
        subject: "Deployment Status"
        body: "Deployment completed with or without errors."
```

#### 6. Шифрование конфиденциальных данных с помощью Vault
Создайте зашифрованный файл с переменными:

```bash
ansible-vault create group_vars/all/vault.yml
```

Добавьте в него конфиденциальные данные, например:

```yaml
db_password: supersecret
```

Используйте переменные из зашифрованного файла в ваших сценариях.

Запускайте ansible-playbook с указанием пароля или файла с паролем:

```bash
ansible-playbook playbook.yml --ask-vault-pass
```
или

```bash
ansible-playbook playbook.yml --vault-password-file ~/.vault_pass.txt
```

### Дополнительные задания
1. **Оптимизация производительности playbook:** Используйте механизм `async` и `poll` для запуска длительных задач в асинхронном режиме. Создайте сценарий, в котором задачи выполняются параллельно, и отслеживается их статус.
2. **Обработка зависимостей:** Настройте ролевую зависимость между несколькими ролями. Например, добавьте зависимость роли базы данных от роли веб-сервера. Реализуйте проверку состояния зависимых ролей перед их выполнением, используя механизм `assert` и `when`.
3. **Использование комбинаций фильтров и переменных:** Создайте сценарий, в котором используются несколько фильтров для преобразования данных из внешних источников (например, данных, полученных через API). Реализуйте задачу, которая фильтрует список данных, основываясь на условии, и отправляет уведомление с результатами.
4. **Работа с Vault для целого проекта:** Перенесите все конфиденциальные данные проекта в зашифрованные файлы Vault. Настройте сценарий для работы с несколькими зашифрованными файлами и используйте различные пароли для каждого из них.

### Вопросы для самопроверки
1. Что такое идемпотентность в Ansible? Почему это важно для автоматизации?
2. Как можно улучшить производительность Ansible playbooks? Приведите примеры механизмов для этого.
3. В чем различие между использованием `block`, `rescue`, и `always`? Приведите пример ситуации, где это необходимо.
4. Что такое фильтры в Ansible? Как они взаимодействуют с шаблонизатором Jinja2?
5. Как Ansible Vault обеспечивает безопасность данных? Можно ли использовать разные ключи шифрования для разных файлов?
6. Какие типы циклов поддерживает Ansible? В чем различия между `loop`, `with_items` и `with_dict`?
7. В каких случаях необходимо использовать динамический инвентарь? Какие преимущества это дает?
8. Какие задачи можно выполнять с помощью подстановок (lookup)? Приведите примеры использования различных типов подстановок.
9. Какие ошибки часто встречаются при работе с неидемпотентными командами? Как их можно решить с помощью Ansible?
10. Как обеспечить откат изменений при ошибке в сценарии Ansible? Какие механизмы для этого существуют?
