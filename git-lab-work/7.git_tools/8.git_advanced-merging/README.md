
# Лабораторная работа №8: Инструменты Git - Продвинутое слияние

## Введение
Обычно выполнять слияния в Git довольно легко. Git упрощает повторные слияния с одной и той же веткой, таким образом, позволяя вам иметь очень долго живущую ветку, и вы можете сохранять её всё это время в актуальном состоянии, часто разрешая маленькие конфликты, а не доводить дело до одного большого конфликта по завершению всех изменений.

Однако, иногда всё же будут возникать сложные конфликты. В отличие от других систем управления версиями, Git не пытается быть слишком умным при разрешении конфликтов слияния. Философия Git заключается в том, чтобы быть умным, когда слияние разрешается однозначно, но если возникает конфликт, он не пытается разрешить его автоматически. Поэтому, если вы слишком долго откладываете слияние двух быстрорастущих веток, вы можете столкнуться с некоторыми проблемами.

В этом разделе мы рассмотрим некоторые из возможных проблем и инструменты, которые предоставляет Git, чтобы помочь вам справиться с этими более сложными ситуациями. Мы также рассмотрим некоторые другие нестандартные типы слияний, которые вы можете выполнять, и вы узнаете, как можно откатить уже выполненные слияния.

## Конфликты слияния
Мы рассказали основы разрешения конфликтов слияния, для работы с более сложными конфликтами Git предоставляет несколько инструментов, которые помогут вам понять, что произошло и как лучше обойтись с конфликтом.

Во-первых, перед слиянием, в котором может возникнуть конфликт, позаботьтесь о том, чтобы ваша рабочая копия была без локальных изменений. Если у вас есть несохранённые наработки, либо сохраните их в временной ветке, либо используйте специальные возможности Git, чтобы легко откатиться назад, если что-то пойдёт не так.

### Пример конфликта
Предположим, у нас есть файл на Ruby, выводящий на экран строку 'hello world':

```ruby
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
```

Теперь мы создадим новую ветку `whitespace` и внесем изменения, связанные с форматированием:

```bash
$ git checkout -b whitespace
$ unix2dos hello.rb
$ git commit -am 'Convert hello.rb to DOS'
```

Затем мы изменим строку на испанский язык:

```bash
$ vim hello.rb
$ git commit -am 'Use Spanish instead of English'
```

После этого переключимся обратно на `master` и добавим комментарий к функции:

```bash
$ git checkout master
$ vim hello.rb
$ git commit -am 'Add comment documenting the function'
```

Теперь мы попытаемся слить ветку `whitespace` в `master` и столкнемся с конфликтом.

```bash
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
```

## Прерывание слияния
Если вы не хотите сейчас решать конфликт, вы можете отменить слияние:

```bash
$ git merge --abort
```

Команда откатит изменения, сделанные до начала слияния.

## Игнорирование пробельных символов
Конфликты вызваны изменениями пробельных символов. Git позволяет проигнорировать такие изменения с помощью флагов:

```bash
$ git merge -Xignore-space-change whitespace
```

## Ручное слияние файлов
Вы также можете выполнить слияние вручную, для этого извлеките все версии конфликтующих файлов:

```bash
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
```

После этого используйте `git merge-file`, чтобы вручную решить конфликт:

```bash
$ git merge-file -p hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb
```

## Игнорирование пробельных символов

Иногда конфликты при слиянии вызваны изменениями пробельных символов. Git предоставляет опции для игнорирования таких изменений:
- **-Xignore-all-space** — игнорирует любые изменения в пробельных символах.
- **-Xignore-space-change** — игнорирует только количество пробелов.

Пример использования команды с игнорированием пробельных символов:

```bash
$ git merge -Xignore-space-change whitespace
```

Git выполнит слияние, игнорируя изменения пробелов:

```bash
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```

## Ручное слияние файлов

Если автоматическое слияние не справляется с изменениями пробелов, вы можете выполнить ручное слияние. Например, с помощью утилиты `dos2unix`.

1. Получите три версии файла для сравнения:
   - Общий предок: 

     ```bash
     $ git show :1:hello.rb > hello.common.rb
     ```
   - Ваша версия:

     ```bash
     $ git show :2:hello.rb > hello.ours.rb
     ```
   - Их версия:

     ```bash
     $ git show :3:hello.rb > hello.theirs.rb
     ```

2. Конвертируйте строки в формат Unix и выполните слияние вручную:

   ```bash
   $ dos2unix hello.theirs.rb
   $ git merge-file -p hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb
   ```

3. Проверьте различия:

   ```bash
   $ git diff -b
   ```

## Сравнение состояний

Для сравнения разных версий файла после слияния используйте команды:

1. Чтобы увидеть изменения, внесённые в вашу ветку:

   ```bash
   $ git diff --ours
   ```

2. Чтобы сравнить результат слияния с другой веткой:

   ```bash
   $ git diff --theirs -b
   ```

3. Чтобы сравнить все состояния:

   ```bash
   $ git diff --base -b
   ```

## Очистка после слияния

После завершения слияния удалите ненужные временные файлы:

```bash
$ git clean -f
```

## Использование команды `git checkout` при конфликтах

Если при слиянии возникают сложности, можно восстановить маркеры конфликтов:

```bash
$ git checkout --conflict=diff3 hello.rb
```

Этот подход покажет не только изменения в вашей и их версии, но и базовую версию файла. Это может помочь лучше понять, как исправить конфликт.

Установите конфликты по умолчанию с использованием `diff3`:

```bash
$ git config --global merge.conflictstyle diff3
```

Теперь Git будет всегда показывать базовую версию файла при конфликтах.


# Лабораторная работа: Продвинутое слияние в Git (Часть 3)

## Конфликт при слиянии веток

Предположим, что у нас есть две долгоживущие ветки, каждая из которых имеет несколько коммитов, что при слиянии приводит к конфликту.

### Лог изменений:

```bash
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code
```

У нас есть три уникальных коммита в ветке `master` и три других в ветке `mundo`. При попытке слияния ветки `mundo` в `master`, возникает конфликт:

```bash
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
```

### Анализ конфликта:

Откроем конфликтующий файл:

```ruby
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
```

Здесь видны изменения в обеих ветках в одной и той же строке, что и вызывает конфликт.

## Инструменты для разрешения конфликта:

### Использование git checkout с опцией --conflict

Вы можете восстановить маркеры конфликта с помощью команды `git checkout` с опцией `--conflict`. Это может быть полезно для повторного анализа конфликта:

```bash
$ git checkout --conflict=diff3 hello.rb
```

После этого файл будет содержать три версии:

```ruby
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
```

Чтобы установить этот формат для всех будущих конфликтов:

```bash
$ git config --global merge.conflictstyle diff3
```

### Использование опций --ours и --theirs

Если нужно выбрать одну из версий без выполнения слияния, можно использовать опции `--ours` или `--theirs`. Это особенно полезно для бинарных файлов или выборочного слияния:

```bash
$ git checkout --ours hello.rb
$ git checkout --theirs hello.rb
```

## Анализ истории для разрешения конфликта

Команда `git log` может помочь проанализировать причины возникновения конфликта. Синтаксис "трёх точек" покажет все уникальные коммиты, включённые в слияние:

```bash
$ git log --oneline --left-right HEAD...MERGE_HEAD
```

Для вывода только тех коммитов, которые изменяли конфликтующий файл:

```bash
$ git log --oneline --left-right --merge
```

### Использование git diff в конфликте

Когда вы находитесь в состоянии конфликта, команда `git diff` покажет различия только для конфликтующих файлов:

```bash
$ git diff
```

Результат будет выглядеть как "Combined Diff":

```diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
```

После разрешения конфликта команда `git diff` покажет обновлённые изменения.

### Лог изменений с разрешением конфликта

После разрешения конфликта, чтобы просмотреть, как был решён конфликт:

```bash
$ git log --cc -p -1
```

Пример вывода:

```diff
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
```

## Отмена слияний

Теперь, когда вы знаете, как создать коммит слияния, можно рассмотреть случаи, когда коммит слияния был сделан по ошибке. Одна из замечательных особенностей Git — это возможность легко исправить ошибку, в том числе слияния.

### Случайный коммит слияния

Допустим, вы начали работать в тематической ветке, случайно слили её в `master`, и теперь история ваших коммитов выглядит следующим образом:

```bash
$ git log --oneline
...
```

### Исправление ссылок

Если случайное слияние произошло только в вашем локальном репозитории, самое простое решение — это переместить указатели веток. Для этого используем команду `git reset --hard`:

```bash
$ git reset --hard HEAD~
```

### Восстановление коммита

Если вам нужно сохранить историю, но отменить последствия слияния, можно использовать команду `git revert`:

```bash
$ git revert -m 1 HEAD
```

Где `-m 1` указывает на основную ветку. Это отменяет слияние и создаёт новый коммит с исправлениями.

### Использование стратегии слияния "ours"

Для специфических ситуаций, когда нужно заставить Git считать, что ветка уже слита (но не использовать её содержимое), применяется стратегия слияния `ours`:

```bash
$ git merge -s ours <branch>
```


Слияние поддеревьев в Git

### 1. Добавление проекта Rack в основной проект
Сначала добавим проект Rack как удалённый репозиторий и загрузим его в отдельную ветку:
```bash
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
```

### 2. Проверка загруженных данных
Убедитесь, что ветка Rack загружена корректно:
```bash
$ git branch -r
```

### 3. Создание новой ветки для проекта Rack
Создайте новую ветку для работы с проектом Rack:
```bash
$ git checkout -b rack_branch rack_remote/master
```

### 4. Проверка содержимого веток
Для проверки, что ветки содержат разный контент, переключитесь между ветками и посмотрите содержимое:
```bash
$ ls
$ git checkout master
$ ls
```

### 5. Включение проекта Rack в подкаталог основного проекта
Считайте данные из ветки Rack в подкаталог основного проекта с помощью команды `read-tree`:
```bash
$ git read-tree --prefix=rack/ -u rack_branch
```

### 6. Коммит изменений
Теперь закоммитьте изменения. Вы увидите, что файлы из проекта Rack добавлены в подкаталог `rack`:
```bash
$ git commit -m "Добавление Rack в подкаталог"
```

### 7. Обновление и слияние изменений из проекта Rack
Если проект Rack был обновлён, переключитесь на ветку Rack и получите последние изменения:
```bash
$ git checkout rack_branch
$ git pull
```

### 8. Слияние изменений в основной проект
Теперь можно слить изменения из ветки Rack обратно в основную ветку. Используем стратегию слияния `subtree` и делаем squash коммит:
```bash
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
```

### 9. Завершение слияния
Закоммитьте результаты слияния:
```bash
$ git commit -m "Слияние обновлений из проекта Rack"
```

### 10. Сравнение изменений между ветками
Для проверки различий между подкаталогом `rack` и содержимым ветки `rack_branch`, выполните:
```bash
$ git diff-tree -p rack_branch
```
