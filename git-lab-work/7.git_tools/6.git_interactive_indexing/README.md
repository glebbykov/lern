
## Лабораторная работа 6: Git Tools — Rewriting History

Неоднократно при работе с Git вам может потребоваться по какой-то причине внести исправления в историю коммитов (commit history). Одно из преимуществ Git заключается в том, что он позволяет вам отложить принятие решений на самый последний момент. Область индексирования (staging area) позволяет вам решить, какие файлы попадут в коммит непосредственно перед его выполнением; благодаря команде git stash вы можете решить, что не хотите продолжать работу над какими-то изменениями; также вы можете внести изменения в сделанные коммиты так, чтобы они отражали то, что вы действительно хотели сохранить.

В этом разделе вы познакомитесь со способами решения всех этих задач и научитесь перед публикацией данных приводить историю коммитов в нужный вам вид.

### Примечание
Не отправляйте свои наработки, пока вы ими не довольны

Одно из основных правил Git заключается в том, что, так как большую часть работы вы делаете в своём локальном репозитории (local repository), то вы вольны переписывать свою историю локально. Однако, как только вы отправите свои наработки в общий репозиторий (shared repository), то это уже совсем другая история, и вам следует рассматривать отправленные изменения как финальные до тех пор, пока у вас не появится весомая причина что-то изменить. Если кратко, то вы должны воздержаться от отправки своих изменений, пока не будете полностью довольны ими и готовы поделиться.

### Изменение последнего коммита (Amending the Last Commit)

Изменение вашего последнего коммита — это, вероятно, наиболее частое исправление истории, которое вы будете выполнять. Обычно с вашим последним коммитом вам потребуется сделать две основные операции: изменить сообщение коммита (commit message) или изменить только что сделанный снимок (snapshot), добавив, изменив или удалив файлы.

Если вы хотите изменить только сообщение вашего последнего коммита, это очень просто:

```bash
$ git commit --amend
```

Эта команда откроет в вашем текстовом редакторе (text editor) сообщение вашего последнего коммита, чтобы вы могли его исправить. Когда вы сохраните его и закроете редактор, будет создан новый коммит, содержащий это сообщение, который теперь и будет вашим последним коммитом.

Если вы создали коммит и затем хотите изменить зафиксированный снимок, добавив или изменив файлы (возможно, вы забыли добавить вновь созданный файл при выполнении исходного коммита), то процесс выглядит в основном так же. Вы добавляете в индекс (staging area) необходимые изменения, редактируя файл и выполняя для него git add или git rm для отслеживаемого файла. Затем команда git commit --amend берёт вашу текущую область подготовленных изменений и создаёт новый снимок для коммита.

Будьте осторожны, используя этот приём, так как при этом изменяется SHA-1 коммита. Поэтому, как и с операцией rebase, не изменяйте ваш последний коммит, если вы уже отправили его в общий репозиторий.

### Подсказка
Изменённый коммит может потребовать изменения сообщения коммита

При изменении коммита существует возможность изменить как его содержимое, так и сообщение коммита. Если в коммит внесены существенные изменения, то почти наверняка следует обновить и его сообщение, чтобы оно более точно отражало содержимое коммита.

С другой стороны, если изменения незначительны (исправление опечаток, добавление в коммит забытого файла), то текущее сообщение вполне можно оставить. Чтобы лишний раз не вызывать редактор, просто добавьте изменённые файлы в индекс и выполните команду:

```bash
$ git commit --amend --no-edit
```

### Изменение сообщений нескольких коммитов (Changing Multiple Commit Messages)

Для изменения коммита, расположенного раньше в вашей истории, вам нужно обратиться к более сложным инструментам. В Git отсутствуют инструменты для непосредственного переписывания истории, но вы можете использовать команду rebase, чтобы перебазировать (rebase) группу коммитов туда же на HEAD, где они были изначально, вместо перемещения их в другое место. С помощью интерактивного режима команды rebase, вы можете останавливаться после каждого нужного вам коммита и изменять сообщения, добавлять файлы или делать что-то другое, что вам необходимо.

Например, если вы хотите изменить сообщения последних трёх коммитов или сообщение какого-то одного коммита из этой группы, то передайте как аргумент команде git rebase -i родителя последнего коммита, который вы хотите изменить — HEAD~3. Вы указываете четвертый коммит с конца — родителя последнего коммита, который вы хотите изменить:

```bash
$ git rebase -i HEAD~3
```

Напомним, что это команда перебазирования — каждый коммит, входящий в диапазон HEAD~3..HEAD, будет изменён вне зависимости от того, изменили вы сообщение или нет. Не включайте в такой диапазон коммит, который уже был отправлен на центральный сервер: сделав это, вы можете запутать других разработчиков, предоставив вторую версию одних и тех же изменений.

## Задание 1: Упорядочивание коммитов

Если вам нужно изменить порядок коммитов или удалить какой-либо коммит, можно сделать это с помощью интерактивного перебазирования. Например, для изменения порядка коммитов выполните:

```bash
git rebase -i HEAD~3
```

```bash
pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
```

Измените команды для второго и третьего коммитов с pick на squash:

```bash
pick 310154e Update README formatting and add blame
pick f7f3f6d Change my name a bit
pick a5f4a0d Add cat-file
```

После этого сохраните изменения и выполните 

```
git rebase --continue
```

## Задание 2: Объединение коммитов

Чтобы объединить несколько коммитов в один, используйте команду squash в интерактивном режиме git rebase -i. Выполните:

```
git rebase -i HEAD~3
```

В редакторе вы увидите:

```bash
pick f7f3f6d Change my name a bit
squash 310154e Update README formatting and add blame
squash a5f4a0d Add cat-file
```

Измените команды для второго и третьего коммитов с pick на squash:

```
pick f7f3f6d Change my name a bit
squash 310154e Update README formatting and add blame
squash a5f4a0d Add cat-file
```

Сохраните файл и закройте редактор. Git объединит эти коммиты в один и предложит вам объединить сообщения коммитов. После объединения сохраните результат.

## Задание 3: Разбиение коммита (Splitting a Commit)

Для разбиения коммита используйте опцию edit. Выполните:

```
git rebase -i HEAD~3
```

В редакторе замените pick на edit для коммита, который нужно разделить:

```bash
pick f7f3f6d Change my name a bit
edit 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file
```

Сохраните и закройте файл. Когда процесс перебазирования остановится на этом коммите, выполните:

```
git reset HEAD^
```

Это сбросит коммит, но сохранит изменения в рабочем каталоге (working directory). Теперь вы можете разделить изменения на несколько коммитов:
1. Добавьте нужные файлы в индекс:

```
git add <file1>
```
2. Зафиксируйте первый коммит:

```
git commit -m "Первое изменение"
```

3. Повторите для остальных изменений.

После этого продолжите перебазирование:

```
git rebase --continue
```

## Задание 4: Удаление коммита

Чтобы удалить коммит, используйте `drop`:

```bash
git rebase -i HEAD~3
```

```bash
pick 461cb2a This commit is OK
drop 5aecc10 This commit is broken
pick a5f4a0d Add cat-file
```

Сохраните изменения и продолжите процесс перебазирования. Git пропустит указанный коммит, и он будет удалён из истории.

## Примечание

Вы можете всегда отменить процесс перебазирования с помощью команды:
```bash
$ git rebase --abort
```
Также можете использовать команду `git reflog` для восстановления предыдущих версий ветки.
